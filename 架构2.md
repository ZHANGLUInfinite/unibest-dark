### 项目架构评估与优化建议

#### 一、仓库合并与整体架构
建议将 `create-unibest` 和 `unibest` 合并为单一monorepo仓库，采用以下结构：
```
packages/
  cli/              # 命令行交互 (create-unibest)
  generator/        # 项目生成引擎
  shared/           # 共享工具函数
  templates/        # 模板资源
    base/           # 基础框架模板
    ui/             # UI库模板
      sard-ui/
      wot-ui/
      uv-ui/
      uview-plus/
    features/       # 功能模块
      i18n/
      token/
```

#### 二、UI库拆分方案评估
**现状**：当前通过分支区分不同UI库，维护成本高
**建议方案**：采用「基础模板+UI插件」模式

1. **合理性分析**：
   - ✅ 优点：仅需维护差异化文件（主要是layouts），避免分支管理混乱
   - ❌ 缺点：需实现模板合并逻辑，增加generator复杂度

2. **具体实现**：
   ```
   templates/
     base/src/layouts/__placeholder__.vue  # 占位文件
     ui/sard-ui/src/layouts/index.vue      # 具体实现
     ui/wot-ui/src/layouts/index.vue       # 具体实现
   ```

#### 三、多维度选择实现
1. **交互式询问流程**（cli/src/prompts.ts）：
   ```typescript
   // 平台选择 → 动态过滤UI库 → 功能模块选择
   const platforms = await selectPlatforms()
   const uiLibraries = filterUILibrariesByPlatform(platforms)
   const features = await selectFeatures()
   ```

2. **模板合并策略**（generator/src/template.ts）：
   ```typescript
   // 1. 复制base模板
   // 2. 根据选择的UI库覆盖对应文件
   // 3. 根据选择的功能模块追加文件
   copyTemplate('base', targetDir)
   overwriteTemplate(`ui/${selectedUI}`, targetDir)
   appendTemplates(features, targetDir)
   ```

#### 四、当前模板目录重构步骤
1. **创建UI子包**：
   ```bash
   mkdir -p packages/templates/ui/{sard-ui,wot-ui,uv-ui,uview-plus}/src/layouts
   ```

2. **迁移差异化文件**：
   ```bash
   # 将各分支的layouts文件迁移到对应UI子包
   mv packages/templates/base/src/layouts/fg-tabbar packages/templates/ui/sard-ui/src/layouts/
   ```

3. **实现功能模块**：
   ```bash
   mkdir -p packages/templates/features/i18n/src/{lang,components}
   ```

#### 五、generator核心逻辑实现
```typescript
// generator/src/index.ts
import { mergeTemplates } from './template'

export async function generateProject(options) {
  const { ui, features, platforms } = options
  await mergeTemplates({
    base: 'base',
    ui,
    features,
    targetDir: options.projectDir
  })
  // 处理平台配置
  // 安装依赖
}
```

#### 六、关键注意事项
1. **版本管理**：所有子包使用统一版本号，通过根目录`pnpm version`统一升级
2. **依赖共享**：公共依赖提升至根目录`package.json`的`peerDependencies`
3. **测试策略**：为每个UI库编写独立的E2E测试
4. **文档更新**：维护`架构-monorepo.md`，添加模板合并流程图

通过以上调整，可实现多维度选择的灵活配置，同时保持代码复用率和维护性。建议优先实现UI库的模板拆分，再逐步迁移功能模块。

## 问：如果未来还想实现单双token和登录模块、图表模块，应当如何设计呢？

### 功能模块扩展设计方案

#### 一、认证与Token模块设计
建议采用「核心逻辑+策略插件」架构，在`features`目录下实现：
```
packages/templates/features/
  auth/
    src/
      strategies/
        single-token.ts   # 单token策略
        double-token.ts   # 双token策略
      login/
        LoginForm.vue     # 登录组件
        api.ts            # 登录接口
      types.ts            # 认证相关类型
    template.config.ts    # 模块配置清单
```

**实现要点**：
1. 使用策略模式封装不同token逻辑
   ```typescript
   // src/strategies/index.ts
   export function createTokenStrategy(type: 'single' | 'double') {
     return type === 'single' ? singleTokenStrategy : doubleTokenStrategy
   }
   ```
2. 登录组件采用Unocss原子化样式
   ```vue
   <!-- LoginForm.vue -->
   <script setup lang="ts">
   // 登录逻辑
   </script>

   <template>
     <div class="flex flex-col gap-4 p-6">
       <input v-model="username" class="border rounded p-2" type="text">
       <input v-model="password" class="border rounded p-2" type="password">
       <button class="bg-blue-500 text-white p-2 rounded">
         登录
       </button>
     </div>
   </template>
   ```

#### 二、图表模块设计
采用「基础封装+UI适配」架构，支持多UI库兼容：
```
packages/templates/ui/
  charts/
    base/
      src/components/
        LineChart.vue     # 基础图表封装
        BarChart.vue
    sard-ui/
      src/components/
        LineChart.vue     # sard-ui适配版本
    wot-ui/
      src/components/
        LineChart.vue     # wot-ui适配版本
```

**关键设计**：
1. 基础图表封装核心逻辑
2. UI适配层仅处理渲染差异
3. 提供统一图表配置接口

#### 三、动态集成机制
修改`generator`实现模块按需集成：
```typescript
// generator/src/index.ts
import { copyBaseTemplate } from './template/base'
import { applyFeatures } from './template/features'

export async function generateProject(options) {
  await copyBaseTemplate(options.targetDir)
  // 应用认证模块
  if (options.features.includes('auth')) {
    await applyFeatures('auth', {
      targetDir: options.targetDir,
      strategy: options.tokenStrategy
    })
  }
  // 应用图表模块
  if (options.features.includes('charts')) {
    await applyFeatures('charts', {
      targetDir: options.targetDir,
      ui: options.uiLibrary
    })
  }
}
```

#### 四、配置文件设计
在各模块根目录添加`template.config.ts`声明模块元信息：
```typescript
// auth/template.config.ts
export default {
  name: 'auth',
  dependencies: [
    { package: 'jwt-decode', version: '^3.1.2' }
  ],
  files: [
    { src: 'src/**/*', dest: 'src/' }
  ],
  conditionalFiles: [
    {
      condition: options => options.tokenStrategy === 'double',
      src: 'strategies/double-token.ts',
      dest: 'src/strategies/current.ts'
    }
  ]
}
```

#### 五、CLI交互扩展
在`cli`包中添加功能选择交互：
```typescript
// cli/src/prompts.ts
export async function promptFeatures() {
  return prompts([
    {
      type: 'multiselect',
      name: 'features',
      message: '选择功能模块',
      choices: [
        { title: '认证系统', value: 'auth' },
        { title: '图表组件', value: 'charts' }
      ]
    },
    {
      type: prev => prev.includes('auth') ? 'select' : null,
      name: 'tokenStrategy',
      message: '选择Token策略',
      choices: [
        { title: '单Token', value: 'single' },
        { title: '双Token', value: 'double' }
      ]
    }
  ])
}
```

#### 六、依赖管理
在根目录`package.json`中声明共享依赖：
```json
{
  "pnpm": {
    "overrides": {
      "jwt-decode": "^3.1.2",
      "echarts": "^5.4.3"
    }
  }
}
```

通过以上设计，可实现功能模块的即插即用，保持代码复用性和扩展性。建议优先实现认证模块，再扩展图表功能，每个模块遵循相同的目录结构和集成规范。

## 问：补充：我的图表主要是使用2中常见的uniapp第三方库：lime-charts 和 ucharts, 与 UI库无关。基于此，如何架构呢？这两个图表库都是现成可用的，我只需要引入并提供demo即可，用户会自己写的。所以不需要那么复杂，更不需要我做适配器。
> 回答得不好，不贴了

## 问：图表库先不考虑，那是以后得事情。现在要考虑的是：我还有一个请求库的选择，有3种：” 选项: 内置 useRequest, alovajs, vue-query”，结合上面的聊天内容，我的整个架构应该如何？

### 请求库选择架构设计方案

#### 一、整体架构设计
采用"核心抽象+多实现"模式，在`shared`包中构建请求层抽象，具体实现根据`requestLibrary`配置动态切换：

```
packages/shared/src/http/
├── abstract/
│   ├── RequestService.ts    // 请求服务抽象接口
│   └── types.ts             // 共享类型定义
├── adapters/
│   ├── useRequestAdapter.ts // 内置useRequest实现
│   ├── alovaAdapter.ts      // alovajs实现
│   └── vueQueryAdapter.ts   // vue-query实现
├── factory.ts               // 请求服务工厂
└── index.ts                 // 对外API
```

#### 二、核心实现
1. **抽象接口定义**
```typescript
// packages/shared/src/http/abstract/RequestService.ts
import type { RequestOptions, RequestResult } from './types'

export abstract class RequestService {
  /**
   * 发起GET请求
   * @param url 请求地址
   * @param options 请求选项
   */
  abstract get<T = any>(url: string, options?: RequestOptions): Promise<RequestResult<T>>

  /**
   * 发起POST请求
   * @param url 请求地址
   * @param data 请求数据
   * @param options 请求选项
   */
  abstract post<T = any>(url: string, data?: any, options?: RequestOptions): Promise<RequestResult<T>>

  // 其他请求方法...
}
```

2. **工厂模式实现**
```typescript
// packages/shared/src/http/factory.ts
import type { RequestService } from './abstract/RequestService'
import { alovaAdapter } from './adapters/alovaAdapter'
import { useRequestAdapter } from './adapters/useRequestAdapter'
import { vueQueryAdapter } from './adapters/vueQueryAdapter'

/**
 * 创建请求服务实例
 * @param library 请求库类型
 */
export function createRequestService(library: string = 'useRequest'): RequestService {
  switch (library) {
    case 'alovajs':
      return new alovaAdapter()
    case 'vue-query':
      return new vueQueryAdapter()
    case 'useRequest':
    default:
      return new useRequestAdapter()
  }
}
```

3. **默认适配器实现**
```typescript
import type { RequestOptions, RequestResult } from '../abstract/types'
import { useRequest } from '~/hooks/useRequest' // 假设内置useRequest实现
// packages/shared/src/http/adapters/useRequestAdapter.ts
import { RequestService } from '../abstract/RequestService'

export class useRequestAdapter extends RequestService {
  async get<T>(url: string, options?: RequestOptions): Promise<RequestResult<T>> {
    const { data, error } = await useRequest<T>({
      url,
      method: 'GET',
      ...options
    })

    if (error) {
      return { success: false, error, data: null }
    }
    return { success: true, data, error: null }
  }

  // post及其他方法实现...
}
```

#### 三、集成到项目生成流程
1. **generator配置**
```typescript
// packages/generator/src/index.ts
import { createPromptModule } from 'inquirer'

const prompt = createPromptModule()

export async function generateProject() {
  // ...现有逻辑
  const { requestLibrary } = await prompt([{
    type: 'list',
    name: 'requestLibrary',
    message: '选择请求库',
    choices: [
      { name: '内置useRequest', value: 'useRequest' },
      { name: 'alovajs', value: 'alovajs' },
      { name: 'vue-query', value: 'vue-query' }
    ],
    default: 'useRequest'
  }])

  // 保存配置到项目
  writeJsonFile(`${targetDir}/src/config/request.json`, {
    library: requestLibrary
  })

  // 根据选择安装依赖
  const dependencies = getRequestLibraryDependencies(requestLibrary)
  if (dependencies.length > 0) {
    await runCommand('pnpm', ['add', ...dependencies], { cwd: targetDir })
  }
}
```

2. **应用入口初始化**
```typescript
import { createRequestService } from '@unibest/shared/http'
// templates/base/src/main.ts
import { createApp } from 'vue'
import App from './App.vue'
import requestConfig from './config/request.json'

// 初始化请求服务
const requestService = createRequestService(requestConfig.library)

// 提供全局请求服务
const app = createApp(App)
app.provide('requestService', requestService)
app.mount('#app')
```

#### 四、使用示例
```vue
<!-- templates/base/src/pages/example/request-demo.vue -->
<script setup lang="ts">
import type { RequestService } from '@unibest/shared/http'
import { inject, onMounted, ref } from 'vue'

const requestService = inject<RequestService>('requestService')
const data = ref<any>(null)
const loading = ref(true)
const error = ref<any>(null)

onMounted(async () => {
  try {
    const result = await requestService?.get('/api/demo')
    if (result?.success) {
      data.value = result.data
    }
  }
  catch (err) {
    error.value = err
  }
  finally {
    loading.value = false
  }
})
</script>

<template>
  <view class="p-4">
    <h1 class="text-2xl font-bold mb-4">
      请求库示例
    </h1>
    <view v-if="loading" class="text-center py-10">
      加载中...
    </view>
    <view v-else-if="error" class="text-red-500 py-10">
      {{ error.message }}
    </view>
    <view v-else class="space-y-4">
      <pre class="p-3 bg-gray-100 rounded">{{ JSON.stringify(data, null, 2) }}</pre>
    </view>
  </view>
</template>
```

#### 五、关键优势
1. **抽象统一接口**：业务代码无需关心具体请求库实现，降低耦合
2. **动态切换能力**：通过配置即可切换请求库，无需修改业务代码
3. **按需加载依赖**：generator根据选择自动安装对应依赖
4. **扩展性良好**：新增请求库只需添加新适配器，符合开闭原则
5. **保持架构一致**：延续monorepo模块化设计，与整体架构风格统一

此方案充分考虑了三种请求库的集成需求，同时保持了架构的清晰性和可维护性，默认使用内置useRequest，用户可根据需求灵活切换。

## 问：alovajs 和 vue-query 都自带了自动生成请求API的功能，如何与我们自己写的 apis/xx.ts 里面的请求一起用呢？

### 自动生成API与手动API共存方案

#### 一、目录结构设计
采用分层存放策略，明确区分自动生成与手动编写的API：
```
templates/base/src/apis/
├── generated/          // 自动生成的API目录
│   ├── alova/          // alovajs生成的API
│   │   ├── user.ts
│   │   └── product.ts
│   └── vue-query/      // vue-query生成的API
│       ├── user.ts
│       └── product.ts
├── manual/             // 手动编写的API目录
│   ├── auth.ts
│   └── payment.ts
└── index.ts            // API统一出口
```

#### 二、统一请求客户端配置
```typescript
// templates/base/src/utils/requestClient.ts
import type { RequestOptions } from '@unibest/shared/http'
import { createRequestService } from '@unibest/shared/http'
import requestConfig from '../config/request.json'

// 创建基础请求客户端
const requestService = createRequestService(requestConfig.library)

/**
 * 配置请求拦截器
 */
requestService.setInterceptors({
  beforeRequest: (options: RequestOptions) => {
    // 添加认证token
    const token = localStorage.getItem('token')
    if (token) {
      options.headers = { ...options.headers, Authorization: `Bearer ${token}` }
    }
    return options
  },
  afterResponse: (response) => {
    // 统一错误处理
    if (!response.success && response.error.code === 401) {
      // 处理未授权错误
      window.location.href = '/login'
    }
    return response
  }
})

export default requestService
```

#### 三、自动生成API集成
1. **alovajs自动生成配置**
```typescript
// templates/base/src/apis/generated/alova/generator.ts
import { defineService, useAlova } from 'alova'
import requestService from '../../../utils/requestClient'

// 创建alova实例，使用统一请求客户端
const alovaInstance = useAlova({
  requestAdapter: ({ method, url, data, headers }) => {
    // 适配到统一请求服务
    return requestService[method.toLowerCase()](url, data, { headers })
  }
})

// 自动生成API（实际项目中可通过脚本根据OpenAPI生成）
export const userService = defineService({
  getUser: (id: number) => alovaInstance.Get(`/users/${id}`),
  updateUser: (id: number, data: any) => alovaInstance.Put(`/users/${id}`, data)
})
```

2. **vue-query自动生成配置**
```typescript
// templates/base/src/apis/generated/vue-query/generator.ts
import { useMutation, useQuery, useQueryClient } from 'vue-query'
import requestService from '../../../utils/requestClient'

// 自动生成查询hooks（实际项目中可通过脚本生成）
export const useUserQueries = {
  useUser: (id: number) => useQuery(
    ['user', id],
    () => requestService.get(`/users/${id}`).then(res => res.data)
  ),
  useUpdateUser: () => {
    const queryClient = useQueryClient()
    return useMutation(
      ({ id, data }: { id: number, data: any }) => requestService.put(`/users/${id}`, data),
      { onSuccess: () => queryClient.invalidateQueries('user') }
    )
  }
}
```

#### 四、手动API实现
```typescript
import type { LoginParams, LoginResult } from '../../types/auth'
// templates/base/src/apis/manual/auth.ts
import requestService from '../../utils/requestClient'

/**
 * 用户登录
 * @param params 登录参数
 */
export async function login(params: LoginParams): Promise<LoginResult> {
  const response = await requestService.post<LoginResult>('/auth/login', params)
  if (response.success) {
    // 登录成功处理
    localStorage.setItem('token', response.data.token)
  }
  return response
}

/**
 * 用户登出
 */
export async function logout(): Promise<void> {
  await requestService.post('/auth/logout')
  localStorage.removeItem('token')
}
```

#### 五、API统一出口
```typescript
// 根据配置动态导出对应库的API
import requestConfig from '../config/request.json'
// templates/base/src/apis/index.ts
// 导出自动生成的API
import * as alovaApis from './generated/alova'

import * as vueQueryApis from './generated/vue-query'
// 导出手动编写的API
import * as authApi from './manual/auth'

import * as paymentApi from './manual/payment'

const generatedApis = requestConfig.library === 'alovajs' ? alovaApis : vueQueryApis

export default {
  ...generatedApis,
  ...authApi,
  ...paymentApi
}
```

#### 六、代码生成脚本
在`package.json`中添加生成脚本：
```json
{
  "scripts": {
    "generate:apis": "openapi-typescript https://api.example.com/openapi.json -o src/apis/generated/schema.ts && ts-node scripts/generate-apis.ts"
  }
}
```

#### 七、使用示例
```vue
<!-- 在组件中使用 -->
<script setup lang="ts">
import type { LoginParams } from '@/types/auth'
import { ref } from 'vue'
import api from '@/apis'

// 使用自动生成的API（根据配置自动切换alova或vue-query）
const { data: user } = api.useUserQueries.useUser(1)

// 使用手动编写的API
async function handleLogin() {
  const params: LoginParams = { username: 'admin', password: '123456' }
  await api.login(params)
}
</script>

<template>
  <view class="p-4">
    <!-- 使用自动生成的API -->
    <view v-if="user">
      {{ user.name }}
    </view>

    <!-- 使用手动编写的API -->
    <button class="bg-blue-500 text-white p-2 rounded" @click="handleLogin">
      登录
    </button>
  </view>
</template>
```

#### 八、关键优势
1. **统一请求上下文**：自动和手动API共享同一请求客户端，确保拦截器、认证等一致
2. **清晰的代码组织**：分离存放自动生成和手动编写的API，便于维护
3. **无缝切换能力**：根据配置自动切换alovajs或vue-query生成的API
4. **类型安全**：所有API都有完整的TypeScript类型定义
5. **扩展性良好**：新增API只需按规范添加到对应目录，无需修改现有逻辑

此方案既保留了自动生成API的便捷性，又兼顾了手动编写API的灵活性，同时通过统一出口和请求客户端确保了架构的一致性。

## 问：用户侧如何使用呢？他们可能只会用其中一种请求库，而且要么都用自动生成的，要么都用手动编写的。

### 请求库使用流程设计

针对用户侧如何使用请求库的问题，结合之前的架构设计，提供以下清晰的使用流程：

#### 1. 初始化选择
在项目创建时，用户通过CLI交互选择：
- 请求库类型（alovajs 或 vue-query）
- API编写方式（自动生成 或 手动编写）

#### 2. 目录结构对应
根据选择自动生成对应目录结构：
```
src/apis/
├── index.ts          # 统一出口
├── requestClient.ts  # 请求客户端配置
├── generated/        # 自动生成API（选择自动模式时）
│   ├── alova/        # alovajs生成文件
│   └── vue-query/    # vue-query生成文件
└── manual/           # 手动编写API（选择手动模式时）
    ├── user.ts
    └── product.ts
```

#### 3. 使用示例
**自动生成模式**（以alovajs为例）：
```vue
// src/views/Example.vue
<script setup lang="ts">
import { useUserList } from '@/apis'

const { data, loading } = useUserList({ page: 1, size: 10 })
</script>

<template>
  <div v-if="loading">
    加载中...
  </div>
  <ul v-else>
    <li v-for="user in data" :key="user.id" class="p-2 border-b">
      {{ user.name }}
    </li>
  </ul>
</template>
```

**手动编写模式**：
```typescript
// src/apis/manual/user.ts
import { requestClient } from '../requestClient'

export async function getUserList(params) {
  return requestClient.get('/api/users', { params })
}
```

#### 4. 核心实现要点
1. **统一出口设计**：`apis/index.ts`根据配置自动导出对应请求库的API
2. **请求客户端共享**：所有API使用同一个`requestClient`，确保拦截器和认证逻辑统一
3. **类型安全**：无论是自动生成还是手动编写，都提供完整的TypeScript类型定义
4. **零配置切换**：通过项目配置文件可随时切换请求库，无需修改业务代码

这种设计确保用户只需关注业务逻辑，无需关心底层请求库实现细节，同时保持了架构的灵活性和可维护性。
